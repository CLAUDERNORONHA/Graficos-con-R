[
["index.html", "Gráficos con R Bienvenido Estructura del libro Software y convenciones Bloques informativos", " Gráficos con R Freddy Hernández Juan Carlos Correa 2019-07-04 Bienvenido Este libro está destinado para estudiantes de ingeniería y estadística que deseen aprender sobre modelos de regresión y la forma de aplicarlos por medio del lenguaje de programación R. Freddy Hernández Juan Carlos Correa Estructura del libro En el capítulo se presenta el modelo de regresión lineal simple y en el Capítulo se generaliza el modelo básico con varias covariables. Software y convenciones Para realizar este libro usamos los paquetes knitr (Xie 2015) y bookdown (Xie 2018) que permiten unir la ventajas de LaTeX y R en un mismo archivo. En todo el libro se presentarán códigos que el lector puede copiar y pegar en su consola de R para obtener los mismos resultados aquí del libro. Los códigos se destacan en una caja de color similar a la mostrada a continuación. 4 + 6 a &lt;- c(1, 5, 6) 5 * a 1:10 Los resultados o salidas obtenidos de cualquier código se destacan con dos símbolos de númeral (##) al inicio de cada línea o renglón, esto quiere decir que todo lo que inicie con ## son resultados obtenidos y NO los debe copiar. Abajo se muestran los resultados obtenidos luego de correr el código anterior. ## [1] 10 ## [1] 5 25 30 ## [1] 1 2 3 4 5 6 7 8 9 10 Bloques informativos En varias partes del libro usaremos bloques informativos para resaltar algún aspecto importante. Abajo se encuentra un ejemplo de los bloques y su significado. Nota aclaratoria. Sugerencia. Advertencia. References "],
["introduccion.html", "1 Introducción ", " 1 Introducción R es un lenguaje de programación usado para realizar procedimientos estadísticos y gráficos de alto nivel, este lenguaje fue creado en 1993 por los profesores e investigadores Robert Gentleman y Ross Ihaka. Inicialmente el lenguaje se usó para apoyar los cursos que tenían a su cargo los profesores, pero luego de ver la utilidad de la herramienta desarrollada, decidieron colocar copias de R en StatLib. A partir de 1995 el código fuente de R está disponible bajo licencia GNU GPL para sistemas operativos Windows, Macintosh y distribuciones Unix/Linux. La comunidad de usuarios de R en el mundo es muy grande y los usuarios cuentan con diferentes espacios para interactuar, a continuación una lista no exhaustiva de los sitios más populares relacionados con R: Rbloggers. Comunidad hispana de R. Nabble. Foro en portugués. Stackoverflow. Cross Validated. R-Help Mailing List. Revolutions. R-statistics blog. RDataMining. Figure 1.1: Robert Gentleman (izquierda) y Ross Ihaka (derecha) creadores de R. Para realizar la instalación de R usted debe visitar la página del CRAN () disponible en este enlace. Una vez ingrese a la página encontrará un cuadro similar al mostrado en la Figura 1.2 donde aparecen los enlaces de la instalación para los sistemas operativos Linux, Mac y Windows. Figure 1.2: Página del Cran. Supongamos que se desea instalar R en Windows, para esto se debe dar clic sobre el hiperenlace de la Figura 1.2. Una vez hecho esto se abrirá una página con el contenido mostrado en la Figura 1.3. Una vez ingrese a esa nueva página usted debe dar clic sobre el hiperenlace como es señalado por la flecha roja en la Figura 1.3. Figure 1.3: Página de instalación para la primera ocasión. Luego de esto se abrirá otra página con un encabezado similar al mostrado en la Figura 1.4, al momento de capturar la figura la versión actual de R era 3.2.5 pero seguramente en este momento usted tendrá disponible una versión actualizada. Una vez allí uste debe dar clic sobre como es señalado por la flecha verde. Luego de esto se descargará el instalador R en el computador el cual deberá ser instalado con las opciones que vienen por defecto. Figure 1.4: Página de descarga. Se recomienda observar el siguiente video didáctico de instalación de R disponible en este enlace para facilitar la tarea de instalación. Una vez que esté instalado R en su computador, usted podrá acceder a él por la lista de programas o por medio del acceso directo que quedó en el escritorio, en la Figura 1.5 se muestra la apariencia del acceso directo para ingresar a R. Figure 1.5: Apariencia del acceso directo para ingresar a R. Al abrir R aparecerá en la pantalla de su computador algo similar a lo que está en la Figura 1.6. La ventana izquierda se llama consola y es donde se ingresan las instrucciones, una vez que se construye un gráfico se activa otra ventana llamada ventana gráfica. Cualquier usuario puede modificar la posición y tamaños de estas ventanas, puede cambiar el tipo y tamaño de las letras en la consola, para hacer esto se deben explorar las opciones de en la barra de herramientas. Figure 1.6: Apariencia de R. En R existen varios tipos de objectos que permiten que el usuario pueda almacenar la información para realizar procedimientos estadísticos y gráficos. Los principales objetos en R son vectores, matrices, arreglos, marcos de datos y listas. A continuación se presentan las características de estos objetos y la forma para crearlos. Los vectores son arreglos ordenados en los cuales se puede almacenar información de tipo numérico (variable cuantitativa), alfanumérico (variable cualitativa) o lógico (TRUE o FALSE), pero no mezclas de éstos. La función de R para crear un vector es c() y que significa concatenar; dentro de los paréntesis de esta función se ubica la información a almacenar. Una vez construído el vector se acostumbra a etiquetarlo con un nombre corto y representativo de la información que almacena, la asignación se hace por medio del operador &lt;- entre el nombre y el vector. A continuación se presenta un ejemplo de cómo crear tres vectores que contienen las respuestas de cinco personas a tres preguntas que se les realizaron. edad &lt;- c(15, 19, 13, NA, 20) deporte &lt;- c(TRUE, TRUE, NA, FALSE, TRUE) comic.fav &lt;- c(NA, &#39;Superman&#39;, &#39;Batman&#39;, NA, &#39;Batman&#39;) El vector edad es un vector cuantitativo y contiene las edades de las 5 personas. En la cuarta posición del vector se colocó el símbolo NA que significa debido a que no se registró la edad para esa persona. Al hacer una asignación se acostumbra a dejar un espacio antes y después del operador &lt;- de asignación. El segundo vector es llamado deporte y es un vector lógico que almacena las respuestas a la pregunta de si la persona practica deporte, nuevamente aquí hay un NA para la tercera persona. El último vector comic.fav contiene la información del cómic favorito de cada persona, como esta variable es cualitativa es necesario usar las comillas ' ' para encerrar las respuestas. Cuando se usa NA para representar una información no se deben usar comillas. Es posible usar comillas sencillas 'foo' o comillas dobles \"foo\" para ingresar valores de una variable cualitativa. Si se desea ver lo que está almacenado en cada uno de estos vectores, se debe escribir en la consola de R el nombre de uno de los objetos y luego se presiona la tecla o , al realizar esto lo que se obtiene se muestra a continuación. edad ## [1] 15 19 13 NA 20 deporte ## [1] TRUE TRUE NA FALSE TRUE comic.fav ## [1] NA &quot;Superman&quot; &quot;Batman&quot; NA &quot;Batman&quot; Las matrices son arreglos rectangulares de filas y columnas con información numérica, alfanumérica o lógica. Para construir una matriz se usa la función matrix( ). Por ejemplo, para crear una matriz de 4 filas y 5 columnas (de dimensión \\(4 \\times 5\\)) con los primeros 20 números positivos se escribe el código siguiente en la consola. mimatriz &lt;- matrix(data=1:20, nrow=4, ncol=5, byrow=FALSE) El argumento data de la función sirve para indicar los datos que se van a almacenar en la matriz, los argumentos nrow y ncol sirven para definir la dimensión de la matriz y por último el argumento byrow sirve para indicar si la información contenida en data se debe ingresar por filas o no. Para observar lo que quedó almacenado en el objeto mimatriz se escribe en la consola el nombre del objeto seguido de la tecla o . mimatriz ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 5 9 13 17 ## [2,] 2 6 10 14 18 ## [3,] 3 7 11 15 19 ## [4,] 4 8 12 16 20 Un arreglo es una matriz de varias dimensiones con información numérica, alfanumérica o lógica. Para construir una arreglo se usa la función array( ). Por ejemplo, para crear un arreglo de \\(3 \\times 4 \\times 2\\) con las primeras 24 letras minúsculas del alfabeto se escribe el siguiente código. miarray &lt;- array(data=letters[1:24], dim=c(3, 4, 2)) El argumento data de la función sirve para indicar los datos que se van a almacenar en el arreglo y el argumento dim sirve para indicar las dimensiones del arreglo. Para observar lo que quedó almacenado en el objeto miarray se escribe en la consola lo siguiente. miarray ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] &quot;a&quot; &quot;d&quot; &quot;g&quot; &quot;j&quot; ## [2,] &quot;b&quot; &quot;e&quot; &quot;h&quot; &quot;k&quot; ## [3,] &quot;c&quot; &quot;f&quot; &quot;i&quot; &quot;l&quot; ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] &quot;m&quot; &quot;p&quot; &quot;s&quot; &quot;v&quot; ## [2,] &quot;n&quot; &quot;q&quot; &quot;t&quot; &quot;w&quot; ## [3,] &quot;o&quot; &quot;r&quot; &quot;u&quot; &quot;x&quot; El marco de datos o es uno de los objetos más utilizados porque permite agrupar vectores con información de diferente tipo (numérica, alfanumérica o lógica) en un mismo objeto, la única restricción es que los vectores deben tener la misma longitud. Para crear un marco de datos se usa la función data.frame( ), como ejemplo vamos a crear un marco de datos con los vectores edad, deporte y comic.fav definidos anteriormente. mimarco &lt;- data.frame(edad, deporte, comic.fav) Una vez creado el objeto mimarco podemos ver el objeto escribiendo su nombre en la consola, a continuación se muestra lo que se obtiene. mimarco ## edad deporte comic.fav ## 1 15 TRUE &lt;NA&gt; ## 2 19 TRUE Superman ## 3 13 NA Batman ## 4 NA FALSE &lt;NA&gt; ## 5 20 TRUE Batman De la salida anterior vemos que el marco de datos tiene 3 variables (columnas) cuyos nombres coinciden con los nombres de los vectores creados anteriormente, los números consecutivos al lado izquierdo son sólo de referencia y permiten identificar la información para cada persona en la base de datos. Las listas son otro tipo de objeto muy usado para almacenar objetos de diferente tipo. La instrucción para crear una lista es list( ). A continuación vamos a crear una lista que contiene tres objetos: un vector con 5 números aleatorios llamado mivector, una matriz de dimensión \\(6 \\times 2\\) con los primeros doce números enteros positivos llamada matriz2 y el tercer objeto será el marco de datos mimarco creado en el apartado anterior. Las instrucciones para crear la lista requerida se muestran a continuación. set.seed(12345) mivector &lt;- runif(n=5) matriz2 &lt;- matrix(data=1:12, ncol=6) milista &lt;- list(E1=mivector, E2=matriz2, E3=mimarco) La función set.seed de la línea número 1 sirve para fijar la semilla de tal manera que los números aleatorios generados en la segunda línea con la función runif sean siempre los mismos. En la última línea del código anterior se construye la lista, dentro de la función list se colocan los tres objetos mivector, matriz2 y mimarco. Es posible colocarle un nombre especial a cada uno de los elementos de la lista, en este ejemplo se colocaron los nombres E1, E2 y E3 para cada uno de los tres elementos. Para observar lo que quedó almacenado en la lista se escribe milista en la consola y el resultado se muestra a continuación. milista ## $E1 ## [1] 0.7209039 0.8757732 0.7609823 0.8861246 0.4564810 ## ## $E2 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 7 9 11 ## [2,] 2 4 6 8 10 12 ## ## $E3 ## edad deporte comic.fav ## 1 15 TRUE &lt;NA&gt; ## 2 19 TRUE Superman ## 3 13 NA Batman ## 4 NA FALSE &lt;NA&gt; ## 5 20 TRUE Batman Así como en el español existen reglas ortográficas, la escritura de códigos en R también tiene unas reglas que se recomienda seguir para evitar confusiones. Tener una buena guía de estilo es importante para que el código creado por usted sea fácilmente entendido por sus lectores (???). No existe una única y mejor guía de estilo para escritura en R, sin embargo aquí vamos a mostrar unas sugerencias basadas en la guía llamada . Se sugiere que el nombre usado para nombrar un archivo tenga sentido y que termine con extensión .R. A continuación dos ejemplos de como nombrar mal y bien un archivo. Se recomienda no usar los símbolos _ y - dentro de los nombres de objetos. Para las variables es preferible usar letras minúsculas y separar las palabras con puntos (peso.maiz) o utilizar la notación camello iniciando en minúscula (pesoMaiz). Para las funciones se recomienda usar la notación camello iniciando todas la palabras en mayúscula (PlotRes). Para los nombres de las constantes se recomienda que inicien con la letra k (kPrecioBus). A continuación ejemplos de buenas y malas prácticas. Para variables: Para funciones: Se recomienda que cada línea tenga como máximo 80 caracteres. Si una línea es muy larga se debe cortar siempre por una coma. Use espacios alrededor de todos los operadores binarios (=, +, -, &lt;-, etc.). Los espacios alrededor del símbolo ``=’’ son opcionales cuando se usan para ingresar valores dentro de una función. Así como en español, nunca coloque espacio antes de una coma, pero siempre use espacio luego de una coma. A continuación ejemplos de buenas y malas prácticas. tab &lt;- table(df[df$days &lt; 0, 2]) # Bien tot &lt;- sum(x[, 1]) # Bien tot &lt;- sum(x[1, ]) # Bien tab &lt;- table(df[df$days&lt;0, 2]) # Faltan espacios alrededor &#39;&lt;&#39; tab &lt;- table(df[df$days &lt; 0,2]) # Falta espacio luego de coma tab &lt;- table(df[df$days &lt; 0 , 2]) # Sobra espacio antes de coma tab&lt;- table(df[df$days &lt; 0, 2]) # Falta espacio antes de &#39;&lt;-&#39; tab&lt;-table(df[df$days &lt; 0, 2]) # Falta espacio alrededor de &#39;&lt;-&#39; tot &lt;- sum(x[,1]) # Falta espacio luego de coma tot &lt;- sum(x[1,]) # Falta espacio luego de coma Otra buena práctica es colocar espacio antes de un paréntesis excepto cuando se llama una función. if (debug) # Correcto if(debug) # Funciona pero no se recomienda colMeans (x) # Funciona pero no se recomienda Espacios extras pueden ser usados si con esto se mejora la apariencia del código, ver el ejemplo siguiente. plot(x = x.coord, y = data.mat[, MakeColName(metric, ptiles[1], &quot;roiOpt&quot;)], ylim = ylim, xlab = &quot;dates&quot;, ylab = metric, main = (paste(metric, &quot; for 3 samples &quot;, sep = &quot;&quot;))) No coloque espacios alrededor del código que esté dentro de paréntesis ( ) o corchetes [ ], la única excepción es luego de una coma, ver el ejemplo siguiente. if (condicion) # Correcto x[1, ] # Correcto if ( condicion ) # Sobran espacios alrededor de condicion x[1,] # Se necesita espacio luego de coma Los signos de agrupación llaves { } se utilizan para agrupar bloques de código y se recomienda que nunca una llave abierta { esté sola en una línea; una llave cerrada } si debe ir sola en su propia línea. Se pueden omitir las llaves cuando el bloque de instrucciones esté formado por una sola línea pero esa línea de código NO debe ir en la misma línea de la condición. A continuación dos ejemplos de lo que se recomienda. if (is.null(ylim)) { # Correcto ylim &lt;- c(0, 0.06) } if (is.null(ylim)) # Correcto ylim &lt;- c(0, 0.06) if (is.null(ylim)) ylim &lt;- c(0, 0.06) # Aceptable if (is.null(ylim)) # No se recomienda { ylim &lt;- c(0, 0.06) } if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} # Frente a la llave { no debe ir nada # la llave de cierre } debe ir sola La sentencia else debe ir siempre entre llaves } {, ver el siguiente ejemplo. if (condition) { one or more lines } else { # Correcto one or more lines } if (condition) { one or more lines } else { # Incorrecto one or more lines } if (condition) one line else # Incorrecto one line Para realizar asignaciones se recomienda usar el símbolo &lt;-, el símbolo de igualdad = no se recomienda usarlo para asignaciones. x &lt;- 5 # Correcto x = 5 # No recomendado Para una explicación más detallada sobre el símbolo de asignación se recomienda visitar este enlace. No se recomienda colocar varias instrucciones separadas por ; en la misma línea, aunque funciona dificulta la revisión del código. n &lt;- 100; y &lt;- rnorm(n, mean=5); hist(y) # No se recomienda n &lt;- 100 # Correcto y &lt;- rnorm(n, mean=5) hist(y) A pesar de la anterior advertencia es posible que en este libro usemos el ; en algunas ocasiones, si lo hacemos es para ahorrar espacio en la presentación del código. "],
["graficos-para-una-variable-cuantitativa.html", "2 Gráficos para una variable cuantitativa 2.1 Función stem 2.2 Función boxplot 2.3 Función hist 2.4 Función qqnorm y qqplot 2.5 Función density ", " 2 Gráficos para una variable cuantitativa En este capítulo se presentan funciones para la creación de gráficos con una sola variable cuantitativa. 2.1 Función stem Esta función permite crear el gráfico llamado de tallo y hoja. Este gráfico fue propuesto por Tukey (1977) y a pesar de no ser un gráfico para presentación definitiva, se utiliza a la vez que el analista recoge la información para ver rápidamente la distribución de los datos. ¿Qué muestra este gráfico? El centro de la distribución. La forma general de la distribución: Simétrica: Si las porciones a cada lado del centro son imágenes espejos de las otras. Sesgada a la izquierda: Si la cola izquierda (los valores menores) es mucho más larga que los de la derecha (los valores mayores). Sesgada a la derecha: Opuesto a la sesgada a la izquierda. Desviaciones marcadas de la forma global de la distribución. Outliers: Observaciones individuales que caen muy por fuera del patrón general de los datos. Gaps: Huecos en la distribución Ventajas del gráfico: Muy fácil de realizar y puede hacerse a mano. Fácil de entender. Desventajas del gráfico: El gráfico es tosco y no sirve para presentaciones definitivas. Funciona cuando el número de observaciones no es muy grande. No permite comparar claramente diferentes poblaciones Ejemplo Como ilustración vamos a crear el gráfico de tallo y hoja para la variable altura (cm) de un grupo de estudiantes de la universidad. Primero se leerán los datos disponibles en github y luego se usará la función stem para obtener el gráfico. A continuación el código usado. url &lt;- &#39;https://tinyurl.com/k55nnlu&#39; datos &lt;- read.table(file=url, header=T) stem(datos$altura) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 14 | 7 ## 15 | 3 ## 15 | 679 ## 16 | 0001 ## 16 | 68888 ## 17 | 001334 ## 17 | 5678899 ## 18 | 000033 ## 18 | 88 ## 19 | 1 De este gráfico sencillo se puede ver que la variable presenta una mayor frecuencia para alturas ente 170 y 179 cm y que no tiene una distribución simétrica. 2.2 Función boxplot La función boxplot sirve para crear un diagrama de cajas y bigote para una variable cuantitativa. La estructura de la función boxplot con los argumentos más comunes de uso se muestran a continuación. boxplot(x, formula, data, subset, na.action, range, width, varwidth, notch, names, plot, col, log, horizontal, add, ...) Los argumentos de la función boxplot son: x: vector numérico con los datos para crear el boxplot. formula: fórmula con la estructura x ~ g para indicar que las observaciones en el vector x van a ser agrupadas de acuerdo a los niveles del factor g. data: marco de datos con las variables. subset: un vector opcional para especificar un subconjunto de observaciones a ser usadas en el proceso de ajuste. na.action: una función la cual indica lo que debería pasar cuando los datos contienen ``NA’s’’. range: valor numérico que indica la extensión de los bigotes. Si es positivo, los bigotes se extenderán hasta el punto más extremo de tal manera que el bigote no supere veces el rango intercuatílico (\\(IQ\\)). Un valor de cero hace que los bigotes se extiendan hasta los datos extremos. width: un vector con los anchos relativos de las cajas. varwidth: Si es TRUE, las cajas son dibujadas con anchos proporcionales a las raíces cuadradas del número de observaciones en los grupos. notch: si es TRUE, una cuña es dibujada a cada lado de las cajas. Cuando las cuñas de dos gráficos de caja no se traslapan, entonces las medianas son significativamente diferentes a un nivel del 5%. names: un con las etiquetas a ser impresas debajo de cada boxplot. plot: si es TRUE (por defecto) entonces se produce el gráfico, de lo contrario, se producen los resúmenes de los boxplots. col: vector con los colores a usar en el cuerpo de las cajas. log: para indicar si las coordenadas x o y o serán graficadas en escala logarítmica. ...: otros parámetros gráficos que pueden ser pasados como argumentos para el boxplot. Ejemplo Como ilustración vamos a crear dos boxplot para la variable altura (cm) de un grupo de estudiantes de la universidad, el primer boxplot será vertical y el segundo horizontal. Primero se leerán los datos disponibles en github y luego se usará la función boxplot para obtener ambos gráfico. A continuación el código usado. url &lt;- &#39;https://tinyurl.com/k55nnlu&#39; datos &lt;- read.table(file=url, header=T) par(mfrow=c(1, 2)) boxplot(x=datos$altura, ylab=&#39;Altura (cm)&#39;) boxplot(x=datos$altura, xlab=&#39;Altura (cm)&#39;, horizontal=TRUE) Figure 2.1: Boxplot para la variable altura. En la Figura 2.1 se presentan los boxplots obtenidos con las instrucciones anteriores. El segundo y tercer boxplot son el mismo, lo único que se modificó fueron los nombres o etiquetas a colocar debajo de cada boxplot por medio del argumento names y la orientación. Ejemplo Es posible crear boxplots comparativos usando 1 o 2 variables cualitativas. A continuación se construyen dos boxplots para la variable precio de apartamentos usados en Medellín. En el primer boxtplot diferencia por la variable balcón (no, si) y en el segundo se diferencia por los cruces de las variables parqueadero y ubicación (en Laureles y Poblado). A continuación se muestra el código necesario para construir los boxplots. En el primero se usa la fórmula precio ~ balcon para crear el boxplot del precio diferenciando por los dos niveles de la variable balcón. En el segundo se usa la fórmula precio ~ ubicacion * parqueadero pero se limitan las ubicaciones a sólo dos, Laureles y Aburrá sur, por esa razón se usa el parámetro subset para incluir la restricción. Se agregó también drop=TRUE para que en el segundo boxplot no aparezcan las otras ubicaciones. url &lt;- &#39;https://tinyurl.com/hwhb769&#39; datos &lt;- read.table(url, header=T) par(mfrow=c(1, 2)) boxplot(precio ~ balcon, data=datos, col=c(&#39;lightblue&#39;, &#39;pink&#39;), xlab=&#39;¿Tiene balcón?&#39;, main=&#39;(a)&#39;, ylab=&#39;Precio (millones $)&#39;) boxplot(precio ~ ubicacion * parqueadero, data=datos, drop=TRUE, col=c(&#39;lightblue&#39;, &#39;pink&#39;), subset=ubicacion %in% c(&#39;laureles&#39;, &#39;aburra sur&#39;), xlab=&#39;Ubicación y parqueadero&#39;, ylab=&#39;Precio (millones $)&#39;, main=&#39;(b)&#39;) Figure 2.2: Boxplot para la variable precio del apartamento. En el pánel (a) de condiciona por la variable balcón y en el pánel (b) por las combinaciones de las variables ubicación y parqueadero. En la Figura 2.2 se muestran los boxplots. Se le recomienda al lector construir nuevamente el segundo boxplot pero eliminando drop=TRUE para que vea el efecto que tiene sobre el dibujo. 2.3 Función hist La función hist sirve para crear el histograma a una variable cuantitativa. Como argumentos esta función recibe un vector con los datos y opcionalmente puede ingresarse como argumento adicional el número de intervalos a ser graficados o en su defecto el número de intervalos se determina con la fórmula de Sturges. Los programas de computador usualmente construyen los histogramas automáticamente, sin embargo, un buen programa debe permitirnos elegir el número de intervalos del histograma. Si usted posee un programa que no le permite hacer cambios, cambie de programa. La estructura de la función hist con los argumentos más comunes de uso se muestran a continuación. x: vector numérico de valores para construir el histograma. breaks: puede ser un número entero que indica el número aproximado de clases o un vector cuyos elementos indican los límites de los intervalos. freq: argumento lógico; si se especifica como TRUE, el histograma presentará frecuencias absolutas o conteo de datos para cada intervalo; si se especifica como FALSE el histograma presentar las frecuencias relativas (en porcentaje). Por defecto, este argumento toma el valor de TRUE siempre y cuando los intervalos sean de igual ancho. include.lowest: argumento lógico; si se especifica como TRUE, un x[i] igual a los equal a un valor breaks se incluirá en la primera barra, si el argumento right = TRUE, o en la última en caso contrario. right: argumento lógico; si es TRUE, los intervalos son abiertos a la izquierda y cerrados a la derecha \\((a,b]\\). Para la primera clase o intervalo si include.lowest=TRUE el valor más pequeño de los datos será incluido en éste. Si es FALSE los intervalos serán de la forma \\([a,b)\\) y el argumento include.lowest=TRUE tendrá el significado de incluir el ``más alto’’. col: para definir el color de las barras. Por defecto, NULL produce barras sin fondo. border: para definir el color de los bordes de las barras. plot: argumento lógico. Por defecto es TRUE, y el resultado es el gráfico del histograma; si se especifica como FALSE el resultado es una lista de conteos por cada intervalo. labels: argumento lógico o carácter. Si se especifica como TRUE coloca etiquetas arriba de cada barra. ...: parámetros gráficos adicionales a title y axis. Ejemplo Vamos a construir varios histogramas para los tiempos de 180 corredores de la media maratón de CONAVI realizada hace algunos años. A continuación se muestra la forma de ingresar los 180 datos. maraton &lt;- c( 10253, 10302, 10307, 10309, 10349, 10353, 10409, 10442, 10447, 10452, 10504, 10517, 10530, 10540, 10549, 10549, 10606, 10612, 10646, 10648, 10655, 10707, 10726, 10731, 10737, 10743, 10808, 10833, 10843, 10920, 10938, 10949, 10954, 10956, 10958, 11004, 11009, 11024, 11037, 11045, 11046, 11049, 11104, 11127, 11205, 11207, 11215, 11226, 11233, 11239, 11307, 11330, 11342, 11351, 11405, 11413, 11438, 11453, 11500, 11501, 11502, 11503, 11527, 11544, 11549, 11559, 11612, 11617, 11635, 11655, 11731, 11735, 11746, 11800, 11814, 11828, 11832, 11841, 11909, 11926, 11937, 11940, 11947, 11952, 12005, 12044, 12113, 12209, 12230, 12258, 12309, 12327, 12341, 12413, 12433, 12440, 12447, 12530, 12600, 12617, 12640, 12700, 12706, 12727, 12840, 12851, 12851, 12937, 13019, 13040, 13110, 13114, 13122, 13155, 13205, 13210, 13220, 13228, 13307, 13316, 13335, 13420, 13425, 13435, 13435, 13448, 13456, 13536, 13608, 13612, 13620, 13646, 13705, 13730, 13730, 13730, 13747, 13810, 13850, 13854, 13901, 13905, 13907, 13912, 13920, 14000, 14010, 14025, 14152, 14208, 14230, 14344, 14400, 14455, 14509, 14552, 14652, 15009, 15026, 15242, 15406, 15409, 15528, 15549, 15644, 15758, 15837, 15916, 15926, 15948, 20055, 20416, 20520, 20600, 20732, 20748, 20916, 21149, 21714, 23256) Los datos están codificados como por seis números en el formato hmmss, donde h corresponde a las horas, mm a los minutos y ss a los segundos necesarios para completar la maratón. Antes de construir los histogramas es necesario convertir los tiempos anteriores almacenados en maraton a horas, para esto se utiliza el siguiente código. horas &lt;- maraton %/% 10000 min &lt;- (maraton - horas * 10000) %/% 100 seg &lt;- maraton - horas * 10000 - min * 100 Tiempos &lt;- horas + min / 60 + seg / 3600 A continuación se muestra el código para construir cuatro histogramas con 2, 4, 8 y 16 intervalos para los tiempos a partir de la variable Tiempos. par(mfrow=c(2,2)) hist(x=Tiempos, breaks=2, main=&quot;&quot;, xlab=&quot;Tiempo (horas)&quot;, ylab=&quot;Frecuencias&quot;, las=1) mtext(&quot;(A)&quot;, side=1, line=4, font=1) hist(x=Tiempos, breaks=4, main=&quot;&quot;, xlab=&quot;Tiempo (horas)&quot;, ylab=&quot;Frecuencias&quot;, las=1) mtext(&quot;(B)&quot;, side=1, line=4, font=1) hist(x=Tiempos, breaks=8, main=&quot;&quot;, xlab=&quot;Tiempo (horas)&quot;, ylab=&quot;Frecuencias&quot;) mtext(&quot;(C)&quot;, side=1, line=4, font=1) hist(x=Tiempos, breaks=16, main=&quot;&quot;, xlab=&quot;Tiempo (horas)&quot;, ylab=&quot;Frecuencias&quot;) mtext(&quot;(D)&quot;, side=1, line=4, font=1) Figure 2.3: Histogramas para el tiempo en la media maratón de CONAVI. A: histograma con dos intervalos, B: histograma con cuatro intervalos, C: histograma con seis intervalos, C: histograma con 18 intervalos. En la Figura 2.3 se presentan los cuatro histogramas. El histograma C, con 8 barras, muestra más claramente la asimetría (este es el que la mayoría de los programas produce por defecto, ya que la regla de Sturges para este conjunto de datos aproxima a 8 barras). Si consideramos más barras por ejemplo 16, como tenemos en D, se refina más la información y empezamos a notar multimodalidad. En el código anterior se incluyó las = 1 para conseguir que los número del eje Y queden escritos de forma horizontal, ver A y B en Figura 2.3. A continuación vamos a construir cuatro histogramas: el primero con dos intervalos intervalos y puntos de corte dados por el mínimo, la mediana y el máximo; el segundo con tres intervalos y puntos de corte dados por el mínimo, cuartiles 1, 2, 3 y máximo; el cuarto con diez intervalos y puntos de corte dados por los deciles; y el último con veinte intervalos y puntos de corte dados por cuantiles 5, 10, \\(\\ldots\\), 95. En el código mostrado a continuación se presenta la creación de los puntos de corte y los cuatro histogramas. puntos1 &lt;- c(quantile(Tiempos, probs=c(0, 0.5, 1))) puntos2 &lt;- c(quantile(Tiempos, probs=c(0, 0.25, 0.5, 0.75, 1))) puntos3 &lt;- c(quantile(Tiempos, probs=seq(0, 1, by=0.1))) puntos4 &lt;- c(quantile(Tiempos, probs=seq(0, 1, by=0.05))) par(mfrow=c(2, 2)) hist(Tiempos, breaks=puntos1, freq=FALSE, ylim=c(0,2), labels=TRUE, main=&quot;&quot;, ylab=&quot;Densidad&quot;) mtext(&quot;(A)&quot;, side=1, line=4, font=1) hist(Tiempos, breaks=puntos2, freq=FALSE, ylim=c(0,2), labels=TRUE, main=&quot;&quot;, ylab=&quot;Densidad&quot;) mtext(&quot;(B)&quot;, side=1, line=4, font=1) hist(Tiempos, breaks=puntos3, freq=FALSE, ylim=c(0,2), main=&quot;&quot;, ylab=&quot;Densidad&quot;) mtext(&quot;(C)&quot;, side=1, line=4, font=1) hist(Tiempos, breaks=puntos4, freq=FALSE, ylim=c(0,2), main=&quot;&quot;, ylab=&quot;Densidad&quot;) mtext(&quot;(D)&quot;, side=1, line=4, font=1) Figure 2.4: Histogramas para el tiempo en la media maratón de CONAVI. A: histograma con dos intervalos, B: histograma con cuatro intervalos, C: histograma con diez intervalos, C: histograma con veinte intervalos. Nota: En estos histogramas, las alturas corresponden a las intensidades (frec. relativa/long. intervalo). Por tanto, el área de cada rectángulo da cuenta de las frecuencias relativas. Para el caso (A) ambos intervalos tienen igual área y cada uno contiene 50% de los datos. esto puede verificarse así: Intensidad primera clase = 1.4869888 = 0.5 / (1.384306 - 1.048056) Intensidad segunda clase = 0.4293381 = 0.5 / (2.548889 - 1.384306) 2.4 Función qqnorm y qqplot Los gráficos cuantil cuantil (quantile-quantile plot) son una ayuda para explorar si un conjunto de datos o muestra proviene de una población con cierta distribución. La función qqnorm sirve para explorar la normalidad de una muestra mientras que la función qqplot es de propósito más general, sirve para crear el gráfico cuantil cuantil para cualquier distribución. La estructura de las funciones con los argumentos más comunes de uso se muestran a continuación. qqnorm(y, ...) qqplot(y, x, ...) La función qqnorm sólo necesita que se le ingrese el vector con la muestra por medio del parámetro y, la función qqplot necesita de la muestra en el parámetro y y que se ingrese en el parámetro x los cuantiles de la población candidata. Existe otra función útil y es qqline, esta función sirve para agregar una línea de referencia al gráfico cuantil cuantil obtenido con qqnorm. Ejemplo Simular 30 observaciones de una distribución \\(N(\\mu=10, \\sigma=4)\\) y construir el gráfico cuantil cuantil. El código para simular la muestra y crear el gráfico cuantil cuantil se muestra a continuación. muestra &lt;- rnorm(n=30, mean=10, sd=4) par(mfrow=c(1, 2)) qqnorm(y=muestra) qqline(y=muestra) qqnorm(y=muestra, main=&#39;&#39;, ylab=&#39;Cuantiles muestrales&#39;, xlab=&#39;Cuantiles teóricos&#39;, las=1) qqline(y=muestra, col=&#39;blue&#39;, lwd=2, lty=2) Figure 2.5: Gráfico cuantil cuantil para una muestra generada de una población normal. En la izquierda de la Figura 2.5 está el gráfico cuantil cuantil sin editar, en la derecha se encuentra el gráfico luego de modificar los nombres de los ejes, grosor y color de la línea de referencia. Ejemplo Simular 100 observaciones de una distribución \\(Weibull(1,1)\\) y construir dos gráficos cuantil cuantil, el primero tomando como referencia los cuantiles de una \\(N(0,1)\\) y el segundo tomando los cuantiles de la \\(Weibull(1,1)\\). El código para simular la muestra y crear los gráficos cuantil cuantil se muestra a continuación. n &lt;- 100 muestra &lt;- rweibull(n=n, shape=1, scale=1) par(mfrow=c(1, 2)) qqplot(y=muestra, x=qnorm(ppoints(n))) qqplot(y=muestra, x=qweibull(ppoints(n), shape=1, scale=1)) Figure 2.6: Gráfico cuantil cuantil para una muestra generada de una población Weibull. En la Figura 2.6 están los gráficos cuantil cuantil solicitados. Del pánel izquierdo de la figura vemos que los puntos NO están alineados, esto indica que la muestra no proviene de la distribución \\(N(0, 1)\\), esto es un resultado esperado ya que sabíamos que la muestra no fue generada de una normal. En el pánel derecho de la misma figura vemos que los puntos SI están alineados, esto indica que la muestra generada puede provenir de una población \\(Weibull(1, 1)\\). Los nombres de los ejes en la Figura 2.6 pueden ser editados para presentar una figura con mejor apariencia. 2.5 Función density Los gráficos de densidad son muy útiles porque permiten ver el(los) intervalo(s) donde una variable cuantitativa puede ocurrir con mayor probabilidad. La función density crea la información de la densidad y la función plot dibuja la densidad. La estructura de la función density con los argumentos más comunes de uso se muestra a continuación. density(x, bw, adjust=1, kernel=&#39;gaussian&#39;, na.rm=FALSE) Los argumentos de la función density son: x: vector con los datos para los cuales se quiere la densidad. bw: ancho de banda. kernel: núcleo de suavización a usar, los posibles valores son gaussian, rectangular, triangular, epanechnikov, biweight, cosine o optcosine, el valor por defecto es gaussian. na.rm: valor lógico, si es TRUE se eliminan los valores con NA para construir la densidad, el valor por defecto es FALSE. Ejemplo Simular mil observaciones de una \\(N(0, 1)\\), aplicar la función density al vector y explorar el contenido de la salida. Primero se generan las observaciones y se almacenan en el objeto y, luego se aplica la función density y el resultado se guarda en el objeto res, para explorar lo que almacena res se usa la función names. A continuación el código utilizado. y &lt;- rnorm(n=1000) res &lt;- density(y) names(res) ## [1] &quot;x&quot; &quot;y&quot; &quot;bw&quot; &quot;n&quot; &quot;call&quot; &quot;data.name&quot; ## [7] &quot;has.na&quot; De la salida anterior se observa que la lista res tiene 7 elementos, los dos primeros son los vectores con las coordenadas para dibujar la densidad, los restantes elementos con información adicional. Ejemplo Con los datos generados en el ejemplo anterior construir la densidad para varios núcleo y para varios valores de ancho de banda. En el siguiente código se construyen 4 densidades para diferentes núcleos. par(mfrow=c(2, 2)) plot(density(y, kernel=&#39;gaussian&#39;)) plot(density(y, kernel=&#39;triangular&#39;)) plot(density(y, kernel=&#39;cosine&#39;)) plot(density(y, kernel=&#39;rectangular&#39;)) Figure 2.7: Densidad para una muestra aleatoria de una N(0, 1) cambiando el núcleo de la densidad. En la Figura 2.7 se muestran las densidades para 4 elecciones del núcleo. En la práctica se usa el núcleo que está por defecto (gaussian) ya que el objetivo de una densidad es ver la zonas donde es más probable encontrar observaciones de la variable. En el siguiente código se construyen 4 densidades para diferentes anchos de banda. par(mfrow=c(2, 2)) plot(density(y, bw=0.1)) plot(density(y, bw=0.2241)) # bw obtenido antes plot(density(y, bw=0.5)) plot(density(y, bw=1)) Figure 2.8: Densidad para una muestra aleatoria de una N(0, 1) cambiando el ancho de banda. En la Figura 2.8 se muestran las densidades para 4 elecciones del parámetro ancho de banda bw, el valor de 0.2241 fue el valor calculado automáticamente por y fue obtenido de la Figura 2.7, los otros valores fueron elegidos arbitrariamente para ver los cambios en la densidad. El usar un ancho de banda pequeño la densidad queda muy rugosa y usar un valor muy grande la suaviza, se recomienda usar el valor automático. Ejemplo Construir un gráfico de densidad para la variable peso corporal de la base de datos medidas_cuerpo, luego construir la densidad para la misma variable pero diferenciando por sexo. url &lt;- &#39;https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo&#39; datos &lt;- read.table(file=url, header=T) par(mfrow=c(1, 2)) plot(density(datos$peso), main=&#39;Distribución del peso corporal&#39;, xlab=&#39;Peso corporal (kg)&#39;, ylab=&#39;Densidad&#39;, lwd=4) den.hom &lt;- with(datos, density(peso[sexo == &#39;Hombre&#39;])) den.muj &lt;- with(datos, density(peso[sexo == &#39;Mujer&#39;])) plot(den.hom, xlim=c(20, 120), main=&#39;Distribución del peso corporal por género&#39;, ylab=&#39;Densidad&#39;, xlab=&#39;Peso corporal (kg)&#39;, lwd=4, col=&#39;blue&#39;) lines(den.muj, lwd=4, col=&#39;red&#39;) legend(&#39;topright&#39;, legend=c(&#39;Hombres&#39;, &#39;Mujeres&#39;), bty=&#39;n&#39;, lwd=3, col=c(&#39;blue&#39;, &#39;red&#39;)) Figure 2.9: Densidad para la variable peso en la izquierda, densidad para el peso diferenciando por sexo a la derecha. En el panel izquierdo de la Figura 2.9 se muestra la densidad para la variable peso, de esta figura se observa que tiene dos sectores de mayor densidad, alrededor de 50 kg y alrededor de 80 kg. En el panel izquierdo están la densidades del peso corporal para hombres y mujeres, aquí se observa claramente la diferencia entre los pesos de hombres y mujeres. "],
["graficos-para-varias-variables-cuantitativas.html", "3 Gráficos para varias variables cuantitativas 3.1 Función plot 3.2 Función sunflowerplot 3.3 Función symbols 3.4 Función pairs 3.5 Función persp 3.6 Función contour 3.7 Función filled.contour 3.8 Función image 3.9 Función kde2d 3.10 Función interaction.plot 3.11 Gráfico de espagueti ", " 3 Gráficos para varias variables cuantitativas En este capítulo se presentan funciones para la creación de gráficos que involucran varias variables cuantitativas. 3.1 Función plot Los gráficos de dispersión son muy útiles porque permiten ver la relación que existe entre dos variables cuantitativas, la función plot permite crear este tipo de gráficos. La estructura de la función plot con los argumentos más usuales se muestra a continuación: plot(x, y, type, main, sub, xlab, ylab) Los argumentos de la función plot son: x: vector numérico con las coordenadas del eje horizontal. y: vector numérico con las coordenadas del eje vertical. type: tipo de gráfico a dibujar. Las opciones son: 'p' para obtener puntos, esta es la opción por defecto. 'l' para obtener líneas. 'b' para obtener los puntos y líneas que unen los puntos. 'c' para obtener sólo las líneas y dejando los espacios donde estaban los puntos obtenidos con la opción 'b'. 'o' para obtener los puntos y lineas superpuestas. 'h' para obtener líneas verticales desde el origen hasta el valor \\(y_i\\) de cada punto, similar a un histograma. 's' para obtener escalones. 'S' similar al anterior. 'n' para que no dibuje. ...: otros parámetros gráficos que pueden ser pasados como argumentos para plot. Ejemplo Crear 16 parejas de puntos tales que \\(x=-5, -4, \\ldots, 9, 10\\) con \\(y=-10+(x-3)^2\\), dibujar los nueve diagramas de dispersión de \\(y\\) contra \\(x\\) usando todos los valores posibles para el parámetro type. A continuación se muestra el código para crear las 16 parejas de \\(x\\) e \\(y\\). Los nueve diagramas de dispersión se observan en la Figura 3.1, de esta figura se observa claramente el efecto que tiene el parámetro type en la construcción del diagrama de dispersión. x &lt;- -5:10 y &lt;- -10 + (x-3)^2 par(mfrow=c(3, 3)) plot(x=x, y=y, type=&#39;p&#39;, main=&quot;con type=&#39;p&#39;&quot;) plot(x=x, y=y, type=&#39;l&#39;, main=&quot;con type=&#39;l&#39;&quot;) plot(x=x, y=y, type=&#39;b&#39;, main=&quot;con type=&#39;b&#39;&quot;) plot(x=x, y=y, type=&#39;c&#39;, main=&quot;con type=&#39;c&#39;&quot;) plot(x=x, y=y, type=&#39;o&#39;, main=&quot;con type=&#39;o&#39;&quot;) plot(x=x, y=y, type=&#39;h&#39;, main=&quot;con type=&#39;h&#39;&quot;) plot(x=x, y=y, type=&#39;s&#39;, main=&quot;con type=&#39;s&#39;&quot;) plot(x=x, y=y, type=&#39;S&#39;, main=&quot;con type=&#39;S&#39;&quot;) plot(x=x, y=y, type=&#39;n&#39;, main=&quot;con type=&#39;n&#39;&quot;) Figure 3.1: Efecto del parámetro type en la función plot. Ejemplo Como ilustración vamos a crear dos diagramas de dispersión entre el precio de apartamentos usados en la ciudad de Medellín y el área de los apartamentos. El primer diagrama es un gráfico básico mientras que el segundo es un diagrama mejorado. El código necesario para cargar la base de datos y construir los diagramas de dispersión se muestra a continuación. url &lt;- &#39;https://tinyurl.com/hwhb769&#39; datos &lt;- read.table(file=url, header=T) par(mfrow=c(1, 2)) plot(x=datos$mt2, y=datos$precio) plot(x=datos$mt2, y=datos$precio, pch=&#39;.&#39;, xlab=&#39;Área del apartamento (m2)&#39;, ylab=&#39;Precio (millones de pesos)&#39;) Figure 3.2: Diagrama de dispersión del precio del apartamento versus área del apartamento. A la izquierda el diagrama de dispersión sin editar y a la derecha el diagrama de dispersión mejorado. En la Figura 3.2 se presentan los diagramas de dispersión entre precio y área de los apartamentos. En el panel de la izquierda está el diagrama básico, de este diagrama se observa claramente que a medida que los apartamentos tienen mayor área el precio promedio y la variabilidad del precio aumentan. En la parte inferior izquierda de este diagrama se tiene una zona de alta densidad de puntos y por esa razón se observa una mancha en el diagrama. Para la construcción del diagrama de dispersión mostrado en el panel derecho se usó el parámetro pch='.' con el objetivo de obtener pequeños puntos que representen cada apartamento y que no se traslapen debido a que se tienen 694 observaciones en la base de datos. 3.2 Función sunflowerplot La función sunflowerplot sirve para crear gráficos de dispersión en los cuales hay parejas repetidas que se superponen y que por lo tanto no se podrían apreciar. Si una pareja está una sola vez se representará por un punto; si la pareja se repite dos veces se representará por un punto y dos rayitas rojas (pétalos); si la pareja se repite tres veces se representará por un punto y tres rayitas rojas (pétalos) y así sucesivamente. La estructura de la función sunflowerplot con los argumentos más usuales se muestra a continuación: sunflowerplot(x, y, pch, seg.col, seg.lwd, ...) Los argumentos de la función plot son: x: vector numérico con las coordenadas del eje horizontal. y: vector numérico con las coordenadas del eje vertical. pch: valor o vector numérico con el tipo de punto a usar, por defecto pch=1. Para conocer los diferentes símbolos que se pueden obtener con el parámetro pch se recomienda consultar la Figura ??. seg.col: color de los pétalos. seg.lwd: ancho de los pétalos. ...: otros parámetros gráficos que pueden ser pasados como argumentos para plot. A continuación se presenta un ejemplo en los cuales se usa la función sunflowerplot para crear gráficos de dispersión. Ejemplo Suponga que se tiene el punto (1, 1) una sola vez, el punto (2, 3) repetido cuatro veces, el punto (3, 2) repetido seis veces y el punto (4, 5) repetido dos veces. El objetivo es crear dos gráficos de dispersión con los trece puntos, uno con la función plot y el otro con la función sunflowerplot para comparar los resultados. A continuación se muestra el código con la creación de los vectores y los dos gráficos de dispersión con plot y sunflowerplot. x &lt;- c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4) y &lt;- c(1, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 5, 5) par(mfrow=c(1, 2)) plot(x, y, main=&#39;a) Usando plot&#39;) sunflowerplot(x, y, seg.col=&#39;blue&#39;, seg.lwd=2, cex=1.5, main=&#39;b) Usando sunflowerplot&#39;) Figure 3.3: Gráfico de dispersión para datos hipotéticos. En la izquierda el gráfico obtenido con plot y a la derecha el obtenido con sunflowerplot. En la Figura 3.3 se muestran los dos gráficos de dispersión para los datos. En el panel de la izquierda está el diagrama obtenido con la función plot pero sólo se observan 4 puntos cuando en realidad eran 13, esto se debe a que hay puntos repetidos y éstos quedan unos sobre otros. En el panel de la derecha está el diagrama obtenido con la función sunflowerplot, en este diagrama se observan cuatro objetos: el punto con coordenadas (1, 1) se representó con un punto ya que él no se repite, el punto (2, 3) está representado por un punto y cuatro pétalos de color azul ya que él se repite cuatro veces, y los puntos (3, 2) y (4, 5) se represetan con seis y dos pétalos porque esas son las veces que ellos se repiten. Ejemplo Como ilustración vamos a crear un diagrama de dispersión con la función sunflowerplot para las variables número de alcobas y número de baños de la base de datos de apartamentos usados. El código necesario para cargar la base de datos y construir el diagrama de dispersión se muestra a continuación. El diagrama de dispersión se construyó excluyendo la información del apartamento 594 porque éste aparece con 14 alcobas. url &lt;- &#39;https://tinyurl.com/hwhb769&#39; datos &lt;- read.table(file=url, header=T) datos &lt;- datos[-594, ] # Sacando el apto 594 sunflowerplot(x=datos$alcobas, y=datos$banos) Figure 3.4: Diagrama de dispersión para número de baños versus número de alcobas. En la Figura 3.4 se muestra el diagrama de dispersión entre número de baños y número de alcobas. De este diagrama se observa que la mayor parte de los apartamentos de la base de datos tienen 2 o 3 alcobas con 2 o 3 baños, se nota que sólo 8 apartamentos tiene 5 alcobas y que sólo un apatamento tiene seis baños. 3.3 Función symbols La función symbols sirve para construir diagramas de dispersión en dos dimensiones incluyendo información adicional de variables cuantitativas. Ejemplo Como ilustración vamos a crear un diagrama de dispersión entre el precio de apartamentos usados en la ciudad de Medellín y el área de los apartamentos pero incluyendo otras variables. url &lt;- &#39;https://tinyurl.com/hwhb769&#39; datos &lt;- read.table(url, header=T) subdat &lt;- subset(datos, ubicacion == &#39;centro&#39;) par(mfrow=c(1, 2)) with(subdat, symbols(x=mt2, y=precio, circles=alcobas, las=1, inches=0.4, fg=&#39;red&#39;, main=&#39;Radio = N° alcobas&#39;)) with(subdat, symbols(x=mt2, y=precio, squares=alcobas, las=1, inches=0.4, fg=&#39;dodgerblue4&#39;, bg=&#39;pink&#39;, main=&#39;Lado = N° alcobas&#39;)) Figure 3.5: Diagrama de dispersión con los símbolos circle y squares para incluir más variables. par(mfrow=c(1, 2)) with(subdat, symbols(x=mt2, y=precio, rectangles=cbind(estrato, alcobas), las=1, inches=0.4, fg=&#39;chartreuse4&#39;, bg=&#39;yellow&#39;, main=&#39;Ancho = estrato y Alto = N° alcobas&#39;)) with(subdat, symbols(x=mt2, y=precio, stars=cbind(estrato, alcobas, banos), las=1, inches=0.4, fg=&#39;purple1&#39;, bg=&#39;tomato&#39;, main=&#39;Estrato, alcobas y n° baños&#39;)) Figure 3.6: Diagrama de dispersión con los símbolos rectangles y stars para incluir más variables. 3.4 Función pairs Las matrices de dispersión obtenidas con la función pairs proporcionan un método simple de presentar las relaciones entre pares de variables cuantitativas y son la versión múltiple de la función plot. Este gráfico consiste en una matriz donde cada entrada presenta un gráfico de dispersión sencillo. Un inconveniente es que si tenemos muchas variables el tamaño de cada entrada se reduce demasiado impidiendo ver con claridad las relaciones entre los pares de variables. La celda \\((i,j)\\) de una matriz de dispersión contiene el gráfico de dispersión de la columna \\(i\\) versus la columna \\(j\\) de la matriz de datos. En la Figura 3.7 se muestra un ejemplo de una matriz de dispersión para un conjunto de datos, en la diagonal están los nombres de las variables y por fuera de la diagonal están los diagramas de dispersión para cada combinación de variables. Figure 3.7: Ilustración de una matriz de dispersión. La estructura de la función pairs con los argumentos más usuales se muestra a continuación: pairs(x, labels, panel = points, ..., horInd = 1:nc, verInd = 1:nc, lower.panel = panel, upper.panel = panel, diag.panel = NULL, text.panel = textPanel, label.pos = 0.5 + has.diag/3, line.main = 3, cex.labels = NULL, font.labels = 1, row1attop = TRUE, gap = 1, log = &quot;&quot;) Los argumentos de la función pairs son: x: matriz o marco de datos con la información de las variables cuantitativas a incluir en la matriz de dispersión. labels: vector opcional con los nombres a colocar en la diagonal, por defecto se usan los nombres de columnas del objeto x. panel: función usual de la forma function(x,y,...) a ser usada para determinar el contenido de los páneles. Por defecto es points, indicando que se graficarán los puntos de los pares de variables. Es posible utilizar aquí otras funciones diseñadas por el usuario. ...: Indica que es posible agregar otros parámetros gráficos, tales como pch y col, con los cuales puede especificarse un vector de símbolos y colores a ser usados en los scatterplots. lower.panel, upper.panel: función usual de la forma function(x,y,...) para definir lo que se desea dibujar en los paneles abajo y arriba de la diagonal. diag.panel: función usual de la forma function(x,y,...) para definir lo que se desea dibujar en la diagonal. text.panel: Es opcional. Permite que una función: function(x, y, labels, cex, font, ...) sea aplicada a los paneles de la diagonal. label.pos: Para especificar la posición \\(y\\) de las etiquetas en el text panel. cex.labels, font.labels: Parámetros para la expansión de caracteres y fuentes a usar en las etiquetas de las variables. row1attop: Parámetro lógico con el cual se especifica si el gráfico para especificar si el diseño lucirá como una matriz con su primera fila en la parte superior o como un gráfico con fila uno en la base. Por defecto es lo primero. Ejemplo Dibujar una matriz de dispersión para las variables precio, área, número de alcobas y número de baños de la base de datos sobre apartamentos en Medellín. A continuación se muestra el código usado para crear el gráfico solicitado. El objeto datos corresponde a la base de datos completa mientras que datos.num es el marco de datos sólo con las variables de interés precio, área, número de alcobas y número de baños. url &lt;- &#39;https://tinyurl.com/hwhb769&#39; datos &lt;- read.table(file=url, header=T) datos.num &lt;- datos[, c(&#39;precio&#39;, &#39;mt2&#39;, &#39;alcobas&#39;, &#39;banos&#39;)] pairs(datos.num) Figure 3.8: Matriz de dispersión para las variables precio, área, número de alcobas y número de baños de la base de datos sobre apartamentos en Medellín. En la Figura 3.8 se muestra la matriz de dispersión para las variables del marco de datos datos.num. Ejemplo Volver a construir la Figura 3.8 editando los nombres de las variables, usando cruces azules en lugar de puntos, en escala logaritmica, con marcas horizontales en el eje vertical y eliminando los diagramas de dispersión abajo de la diagonal. Para obtener la nueva matriz de dispersión con los cambios solicitados se usa el siguiente código. En la Figura 3.9 se presenta la nueva matriz de dispersión. pairs(datos.num, lower.panel=NULL, cex.labels=1.5, log=&#39;xy&#39;, main=&#39;Matriz de dispersión&#39;, las=1, labels=c(&#39;Precio&#39;, &#39;Área&#39;, &#39;Num alcobas&#39;, &#39;Num baños&#39;), pch=3, cex=0.6, col=&#39;dodgerblue2&#39;) Figure 3.9: Matriz de dispersión modificando los parámetros adicionales de la función pairs. Ejemplo Construir una matriz de dispersión con las variables precio, área y avaluo para apartamentos que cumplan la condición \\(100 m^2 &lt; area &lt; 130 m^2\\). Adicionalmente, se deben diferenciar los apartamentos sin parqueadero con color rojo y los apartamentos con parqueadero con color verde. Para crear una matriz de dispersión se puede tambien usar la base de datos original llamada datos que contiene todas las variables y usar una fórmula con la ayuda del operador ~ para indicar las variables de interés. La fórmula NO debe contener nada del lado izquierdo mientras que en el lado derecho se colocan todas las variables a considerar en la matriz de dispersión, por esta razón es que en el códido mostrado abajo se inicia con la instrucción ~ precio + mt2 + avaluo. Para incluir condiciones se usa el parámetro subset de la siguiente manera: subset=mt2 &gt; 100 &amp; mt2 &lt; 130. A continuación el código completo para construir la matriz de dispersión solicitada. col1 &lt;- ifelse(datos$parqueadero == &#39;no&#39;, &#39;red&#39;, &#39;green3&#39;) pairs(~ precio + mt2 + avaluo, data=datos, lower.panel=NULL, col=col1, subset=mt2 &gt; 100 &amp; mt2 &lt; 130, pch=19, cex=0.8, main=&quot;Matriz de dispersión para aptos con 100 &lt; área &lt; 130 mt2&quot;) Figure 3.10: Matriz de dispersión con un subconjunto de los datos y con colores para identificar los puntos. En la Figura 3.10 se presenta la matriz de dispersión solicitada, los puntos rojos representan los apartamento sin parqueadero mientras que los puntos verdes son los apartamento que si tienen parqueadero. Ejemplo ¿Es posible agregar una leyenda a una matriz de dispersión? Claro que es posible, se construye la matriz de dispersión y se deja en el lienzo del dibujo un espacio para colocar la leyenda. A continuación se muestra un ejemplo disponible en Stackoverflow. A continuación se muestra el código para el ejemplo y en la Figura 3.11 se presenta el resultado. pairs(iris[1:4], main=&quot;Anderson&#39;s Iris Data -- 3 species&quot;, pch=21, bg=c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)[iris$Species], oma=c(4, 4, 6, 12)) par(xpd=TRUE) legend(0.85, 0.7, as.vector(unique(iris$Species)), bty=&#39;n&#39;, fill=c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)) Figure 3.11: Matriz de dispersión con leyenda. Ejemplo ¿Es posible modificar el contenido de los páneles de una matriz de dispersión? Claro que es posible, para hacer esto se definen funciones que hagan lo que se desea ver tanto en la diagonal como arriba y abajo de la misma. Como ejemplo vamos a construir una matriz de dispersión que cumpla: sobre la diagonal un diagrama de dispersión para las variables involucradas y la recta de regresión ajustada, en la diagonal un histograma para la variable, debajo de la diagonal el coeficiente de correlación entre las variables involucradas y usando un tamaño de fuente proporcional a la fuerza de correlación. Para obtener esta matriz de dispersión especial se definen a continuación las funciones panel.reg, panel.hist y panel.cor, a continuación el código utilizado. Luego se usa la función pairs y se indica qué función debe actuar en cada uno de los parámetros upper.panel, diag.panel y lower.panel. # Función para dibujar los puntos y agregar la recta de regresión panel.reg &lt;- function (x, y) { points(x, y, pch=20) abline(lm(y ~ x), lwd=2, col=&#39;dodgerblue2&#39;) } # Función para crear el histograma panel.hist &lt;- function(x, ...) { usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(usr[1:2], 0, 1.5) ) h &lt;- hist(x, plot = FALSE) breaks &lt;- h$breaks; nB &lt;- length(breaks) y &lt;- h$counts; y &lt;- y/max(y) rect(breaks[-nB], 0, breaks[-1], y, col=&quot;dodgerblue2&quot;, ...) } # Función para obtener la correlación panel.cor &lt;- function(x, y, digits=2, prefix=&quot;&quot;, cex.cor) { usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(0, 1, 0, 1)) r &lt;- abs(cor(x, y)) txt &lt;- format(c(r, 0.123456789), digits=digits)[1] txt &lt;- paste(prefix, txt, sep=&quot;&quot;) if(missing(cex.cor)) cex &lt;- 0.8/strwidth(txt) text(0.5, 0.5, txt, cex = cex * r) } pairs(datos.num, upper.panel = panel.reg, diag.panel = panel.hist, lower.panel = panel.cor) Figure 3.12: Matriz de dispersión con páneles modificados. En la Figura 3.12 se presenta la matriz de dispersión con las modificaciones en cada uno de los páneles. Cualquier usuario puede modificar las funciones panel.reg, panel.hist y panel.cor para personalizar la apariencia de los contenidos. La función panel.smooth está disponible en para que el usuario pueda incluir arriba o abajo de la diagonal un diagrama de dispersión con una línea resultado de un ajuste suavizado. Abajo se muestra el código de cómo incluir la función panel.smooth y en la Figura 3.13 se muestra gráfico obtenido. pairs(datos.num, upper.panel = panel.reg, diag.panel = panel.hist, lower.panel = panel.smooth) Figure 3.13: Matriz de dispersión usando la función panel.smooth. Al construir un gráfico con pairs se recomienda no incluir demasiadas variables porque el gráfico se satura y no se pueden apreciar los patrones con facilidad. Se recomienda máximo 10 variables. 3.5 Función persp La función persp dibuja superfices en tres dimensiones y es posible rotar la superficie para obtener una perpectiva apropiada. La estructura de la función persp con los argumentos más usuales se muestra a continuación: persp(x, y, z, main, sub, theta, phi, r, col, border, box, axes, nticks) Los argumentos de la función plot son: x: vector numérico con los valores de \\(x\\) donde fue evaluada la función o superficie. y: vector numérico con los valores de \\(y\\) donde fue evaluada la función o superficie. z: matriz que contiene las alturas \\(z\\) de la supercifie para cada combinación de \\(x\\) e \\(y\\). main: vector numérico con las coordenadas del eje vertical. sub: vector numérico con las coordenadas del eje vertical. theta, phi: ángulo para la visión de la superficie, theta para la dirección azimutal y phi para latitud. Ver Figura 3.14 para una ilustración de los ángulos. r: distancia entre el centro de la caja de dibujo al punto de vista. col: color de la superficie. border: color para el borde de la superficie. box: valor lógico para indicar si se quiere dibujar la caja que contiene la superficie, por defecto es TRUE. axes: valor lógico para indicar si se desean marcas en los ejes y nombres de los ejes, por defecto es TRUE. Si box='FALSE' no aparecen marcas ni nombres de los ejes. expand: factor de expansión aplicado a los valores en el eje z. ticktype: tipo de marcas a colocar en los ejes, simple no dibuja nada y detailed coloca números a los ejes. nticks: número aproximado de marcas en los ejes. Figure 3.14: Ilustración de los ángulos theta y phi para la función persp. Figura tomada de https://i-msdn.sec.s-msft.com/dynimg/IC412528.png Ejemplo Dibujar la superficie asociada a la función \\(f(x, y)=sen(x^2+y^2)\\) para \\(-2 \\leq x \\leq2\\) y \\(-2 \\leq y \\leq2\\). Usar 4 combinaciones de los parámetros theta y phi para obtener un buen punto de vista de la superficie. Lo primero que se debe hacer es crear la función \\(f(x, y)\\) la cual se va a llamar fun. Luego se definen los vectores x e y tomando por ejemplo 25 puntos equiespaciados en el intervalo \\([-2, 2]\\). Luego se usa la función outer para crear la rejilla o matriz que contiene los valores de \\(f(x, y)\\) para cada combinación de x e y, los resultados se almacenan en el objeto z. Por último se dibujan 4 perspectivas de la función variando los parámetros theta y phi de la función persp. A continuación el código utilizado. fun &lt;- function(x, y) sin(x^2 + y^2) x &lt;- seq(from=-2, to=2, length.out=25) y &lt;- seq(from=-2, to=2, length.out=25) z &lt;- outer(x, y, fun) par(mfrow=c(2, 2), mar=c(1, 1, 2, 1)) persp(x, y, z, zlim=c(-1, 1.5), theta=0, phi=0, col=&#39;aquamarine&#39;, main=&#39;(A) theta=0, phi=0&#39;) persp(x, y, z, zlim=c(-1, 1.5), theta=15, phi=15, col=&#39;lightpink&#39;, main=&#39;(B) theta=15, phi=15&#39;) persp(x, y, z, zlim=c(-1, 1.5), theta=45, phi=30, col=&#39;yellow1&#39;, main=&#39;(c) theta=45, phi=30&#39;) persp(x, y, z, zlim=c(-1, 1.5), theta=60, phi=50, col=&#39;lightblue&#39;, main=&#39;(D) theta=60, phi=50&#39;) Figure 3.15: Superficie generada con persp y diferentes valores de theta y phi. En la Figura 3.15 se presentan las 4 perspectivas de la función \\(f(x, y)=sen(x^2+y^2)\\). De los 4 páneles se nota que (C) y (D) muestran mejor la superficie de interés. Al aumentar el valor del parámetro length.out en la creación de los vectores x e y se obtendrá una rejilla más tupida, se recomienda modificar este valor para obtener una superficie apropiada. Ejemplo Dibujar la superficie de una distribución normal bivariada con vector de medias \\(\\boldsymbol{\\mu}=(5, 12)^\\top\\), varianzas unitarias y covarianza con valor de -0.8. Explorar el efecto de los parámetros ticktype, nticks, expand, axes y box. Primero se define el vector de medias y la matriz de varianzas y covarianzas, luego se carga el paquete mvtnorm que contiene la función dmvnorm que calcula la densidad dado el vector de medias y la matriz de varianzas y covarianzas. Se construye la función fun y se vectoriza para luego obtener las alturas de la superficie con la ayuda de outer. Por último se dibujan tres perspectivas diferentes para la densidad modificando los parámetros ticktype, nticks, expand, axes y box, a continuación el código usado. media &lt;- c(5, 12) varianza &lt;- matrix(c(1, -0.8, -0.8, 1), ncol=2) require(mvtnorm) fun &lt;- function(x, y) dmvnorm(c(x, y), mean=media, sigma=varianza) fun &lt;- Vectorize(fun) x &lt;- seq(from=2, to=8, length.out=30) y &lt;- seq(from=9, to=15, length.out=30) z &lt;- outer(x, y, fun) par(mfrow=c(1, 3), mar=c(1, 1, 2, 1)) persp(x, y, z, theta=30, phi=30, ticktype = &quot;detailed&quot;, nticks=4) persp(x, y, z, theta=30, phi=30, col=&#39;salmon1&#39;, expand=0.5, axes=FALSE) persp(x, y, z, theta=30, phi=30, col=&#39;springgreen1&#39;, expand=0.2, box=FALSE) Figure 3.16: Distribución normal bivariada. En la Figura 3.16 se presentan las 3 perspectivas para la densidad. Note los efectos que ticktype, nticks, expand, axes y box tienen sobre los dibujos de las perspectivas. 3.6 Función contour La función contour dibuja gráficos contornos. La estructura de la función contour con los argumentos más usuales se muestra a continuación: contour(x, y, z, xlim, ylim, zlim, levels, nlevels=20, col) Los argumentos de la función son: x, y: vectores numéricos en los cuales se evaluó la función de interés para construir el objeto z. Ambos vectores deben estar ordenados. z: matriz con las alturas de la función de interés, por lo general creada con la función outer. xlim, ylim, zlim: límites de los ejes x, y e z respectivamente. nlevels: número aproximado de niveles o cortes en la superficie a representar. col: color a usar en las líneas de contornos. La función contour tiene otros parámetros adicionales que el lector puede consultar en la ayuda usando help(contour). Ejemplo Generar una muestra aleatoria de 50 observaciones de una distribución normal con parámetros \\(\\mu=170\\) y \\(\\sigma^2=25\\). Dibujar un gráfico de contornos para la superficie de log-verosimilitud. La muestra aleatoria se genera con el siguiente código. y &lt;- rnorm(n=50, mean=170, sd=5) # sd es desviación Para dibujar los contornos solicitados se debe primero construir la función de log-verosimilitud llamada ll. A continuación el código para crear ll, mayores detalles de cómo construir funciones de log-verosimilitud se pueden consultar en (???). ll &lt;- function(a, b) sum(dnorm(x=y, mean=a, sd=b, log=TRUE)) ll &lt;- Vectorize(ll) # Para vectorizar la función Una vez construída la función ll se deben construir los vectores con las coordenadas horizontal y vertical donde se evalua la función ll. En el código mostrado abajo se tienen dos vectores xx e yy obtenidos como secuencias desde el menor valor hasta el mayor valor para cada uno de los parámetros \\(\\mu\\) y \\(\\sigma\\) de la distribución normal, el valor by=0.5 indica el tamaño de paso de la secuencia. Luego se construye la matriz zz usando la función outer evaluando ll en xx e yy. Por último la función contour se aplica sobre los elementos xx, yy e zz. En la Figura 3.17 se muestra el gráfico de contornos con aproximadamente 50 niveles. xx &lt;- seq(from=160, to=180, by=0.5) yy &lt;- seq(from=3, to=7, by=0.5) zz &lt;- outer(X=xx, Y=yy, ll) contour(x=xx, y=yy, z=zz, nlevels=50, col=gray(0.3), lwd=2, lty=&#39;solid&#39;, xlab=expression(mu), ylab=expression(sigma)) Figure 3.17: Gráfico de contornos para la función de log-verosimilitud para el ejemplo sobre normal. 3.7 Función filled.contour La función filled.contour dibuja gráficos contornos pero usando una paleta de colores, este tipo de representación se denomina gráfico de nivel. La estructura de la función filled.contour con los argumentos más usuales se muestra a continuación: filled.contour(x, y, z, xlim, ylim, zlim, levels, nlevels=20, color.palette=cm.colors, col) Los argumentos de la función son: x, y: vectores numéricos en los cuales se evaluó la función de interés para construir el objeto z. Ambos vectores deben estar ordenados. z: matriz con las alturas de la función de interés, por lo general creada con la función outer. xlim, ylim, zlim: límites de los ejes x, y e z respectivamente. nlevels: número aproximado de niveles o cortes en la superficie a representar. color.palette: paleta de colores a usar. Por defecto es cm.colors pero el usuario puede elegir entre heat.colors, terrain.colors o topo.colors. La función filled.contour tiene otros parámetros adicionales que el lector puede consultar en la ayuda usando help(filled.contour). Ejemplo Abajo se muestra el código para crear un gráfico de nivel usando los datos del ejemplo anterior. Observe que las figuras 3.17 y 3.18 son bastante similares. filled.contour(x=xx, y=yy, z=zz, nlevels=20, xlab=expression(mu), ylab=expression(sigma), color = topo.colors) Figure 3.18: Gráfico de nivel para la función de log-verosimilitud para el ejemplo sobre normal. Ejemplo ¿Es posible crear un gráfico de contornos y de niveles en la misma figura? Claro que si, abajo se muestra el código para crear primero el gráfico de niveles (en colores) y luego superponer el gráficos de contornos (las lineas). En la Figura 3.19 se muestra el gráfico resultante. filled.contour(x=xx, y=yy, z=zz, nlevels=20, color.palette = topo.colors, plot.axes=contour(xx, yy, zz, nlevels=20, add=TRUE)) Figure 3.19: Gráfico de nivel y contornos para la función de log-verosimilitud para el ejemplo sobre normal. 3.8 Función image La función image dibuja un gráfico de calor similar al obtenido con la función filled.contour. La estructura de la función image con los argumentos más usuales se muestra a continuación: image(x, y, z) Los argumentos de la función son: x, y: vectores numéricos en los cuales se evaluó la función de interés para construir el objeto z. Ambos vectores deben estar ordenados. z: matriz con las alturas de la función de interés, por lo general creada con la función outer. Ejemplo Para la muestra aleatoria obtenida en el ejemplo anterior, dibujar un gráfico con image para la superficie de log-verosimilitud. Usando los objetos xx, yy e zz creados en el ejemplo anterior se puede construir el gráfico solicitado, a continuación el código utilizado. En la Figura 3.20 se muestra el gráfico. image(x=xx, y=yy, z=zz, xlab=expression(mu), ylab=expression(sigma)) Figure 3.20: Gráfico para la función de log-verosimilitud para el ejemplo sobre normal. 3.9 Función kde2d La función kde2d pertenece al paquete MASS y es utilizada para crear densidades para dos variables cuantitativas. La estructura de la función kde2d con los argumentos más usuales se muestra a continuación: kde2d(x, y, h, n = 25, lims = c(range(x), range(y))) Los argumentos de la función son: x: vector con la variable para el eje X. y: vector con la variable para el eje Y.. h: vector con los anchos de banda en las direcciones X e Y. n: número de puntos para construir la rejilla. lims: límites del rectángulo de datos a considerar, debe ser un vector de la forma c(xl, xu, yl, yu). Este parámetro por defecto es c(range(x), range(y)). Ejemplo La base de datos medidas del cuerpo cuenta con 6 variables registradas a un grupo de 36 estudiantes de la universidad, dos de esas variables son la altura y el peso corporal. Se desea construir un gráfico de densidad bivariada para altura y peso. El código mostrado a continuación hace la lectura de la base de datos y luego se construyen dos densidades, la primera con n=5 y la segunda con n=50, esto para ver el efecto del parámetro n. url &lt;- &#39;https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo&#39; datos &lt;- read.table(file=url, header=T) require(MASS) # Se debe cargar este paquete f1 &lt;- kde2d(x=datos$peso, y=datos$altura, n=5) f2 &lt;- kde2d(x=datos$peso, y=datos$altura, n=50) En el código mostrado a continuación se dibujan las dos densidades usando un gráfico de calor usando la función image. par(mfrow=c(1, 2)) image(f1, xlab=&#39;Peso&#39;, ylab=&#39;Estatura&#39;, main=&#39;n=5&#39;) image(f2, xlab=&#39;Peso&#39;, ylab=&#39;Estatura&#39;, main=&#39;n=50&#39;) Figure 3.21: Gráfico de densidad bivariada para el peso corporal y la estatura de un grupo de estudiantes. A la izquierda la densidad con n=5 y a la derecha con n=50. 3.10 Función interaction.plot La función interaction.plot dibuja gráficos de interacción. La estructura de la función interaction.plot con los argumentos más usuales se muestra a continuación: interaction.plot(response, x.factor, trace.factor, fun, legend, trace.label) Los argumentos de la función son: response: vector numérico con la variable respuesta. x.factor: factor 1 a ubicar en el eje horizontal. trace.factor: factor 2 para diferenciar las líneas. fun: función a aplicar para a response para cada combinación de x.factor y trace.factor. legend: valor lógico para incluir o no leyenda. trace.label: nombre a colocar en la leyenda. La función interaction.plot tiene otros parámetros adicionales que el lector puede consultar en la ayuda usando help(interaction.plot). Ejemplo Se realizó un experimento para determinar cómo influye el material de la batería y la temperatura del medio ambiente sobre la duración en horas de la batería. Se desea construir un gráfico de interacción entre Temperatura y Material para ver el efecto sobre la duración promedio de las baterías. Los datos y el código para generar el gráfico solicitado se muestran a continuación. horas &lt;- c(130, 155, 74, 180, 150, 188, 159, 126, 138, 110, 168, 160, 34, 40, 80, 75, 136, 122, 106, 115, 174, 120, 150, 139, 20, 70, 82, 58, 25, 70, 58, 45, 96, 104, 82, 60) temperatura &lt;- rep(c(15, 70, 125), each=12) material &lt;- rep(1:3, each=4, times=3) interaction.plot(x.factor=temperatura, trace.factor=material, response=horas, trace.label=&#39;Material&#39;, xlab=&#39;Temperatura&#39;, ylab=&#39;Duración promedio (horas)&#39;, col=c(&#39;dodgerblue3&#39;, &#39;chartreuse4&#39;, &#39;salmon3&#39;), fun=mean, lwd=2, las=1, fixed=T) Figure 3.22: Gráfico de interacción entre Temperatura y Material sobre la duración promedio de las baterías. 3.11 Gráfico de espagueti Los gráficos de espagueti son usados para representar la evolución de una variable medida para un grupo de sujetos en diferentes momentos del tiempo. La función interaction.plot se puede usar para obtener este tipo de gráficos, a continuación un ejemplo. Ejemplo El ejemplo aquí presentado fue tomado de este enlace. El objetivo es crear un gráfico de espagueti para mostrar la evolución de la variable tolerancia a través del tiempo para cada uno de los 16 individuos estudiados. El código para descargar la base de datos y construir el gráfico se muestran a continuación. dt &lt;- read.table(&quot;https://stats.idre.ucla.edu/stat/r/faq/tolpp.csv&quot;, sep=&quot;,&quot;, header=T) require(gplots) # Paquete especial para crear una paleta palette(rich.colors(16)) # de 16 colores diferentes y suaves interaction.plot(response=dt$tolerance, x.factor=dt$time, col=1:16, lwd=2, trace.factor=dt$id, las=1, lty=1, xlab=&quot;Tiempo&quot;, ylab=&quot;Tolerancia&quot;, legend=F) Figure 3.23: Gráfico de espagueti para ver la evolución de la variable tolerancia. "]
]
